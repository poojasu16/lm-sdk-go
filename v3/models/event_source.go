// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EventSource event source
//
// swagger:discriminator EventSource collector
type EventSource interface {
	runtime.Validatable
	runtime.ContextValidatable

	// The alert message body for the EventSource
	AlertBodyTemplate() string
	SetAlertBodyTemplate(string)

	// The time in minutes after which the alert should clear
	// Required: true
	AlertEffectiveIval() *int32
	SetAlertEffectiveIval(*int32)

	// The default alert level: warn | error |critical
	AlertLevel() string
	SetAlertLevel(string)

	// The alert message subject for the EventSource
	AlertSubjectTemplate() string
	SetAlertSubjectTemplate(string)

	// The Applies To for the LMModule
	AppliesTo() string
	SetAppliesTo(string)

	// Whether or not the alert should clear after acknowledgement
	ClearAfterAck() bool
	SetClearAfterAck(bool)

	// The EventSource type: logfile | snmptrap | syslog | wineventlog | scriptevent
	Collector() string
	SetCollector(string)

	// The description for the LMModule
	Description() string
	SetDescription(string)

	// The filters for the EventSource
	Filters() []*RestEventSourceFilter
	SetFilters([]*RestEventSourceFilter)

	// The group the LMModule is in
	Group() string
	SetGroup(string)

	// The ID of the LMModule
	// Required: true
	// Read Only: true
	ID() int32
	SetID(int32)

	// The name of the EventSource
	// Required: true
	Name() *string
	SetName(*string)

	// Whether or not duplicate alerts should be suppressed at eventsource level
	SuppressDuplicatesES() bool
	SetSuppressDuplicatesES(bool)

	// The Tags for the LMModule
	Tags() string
	SetTags(string)

	// The Technical Notes for the LMModule
	Technology() string
	SetTechnology(string)

	// The epoch time of the last update to the EventSource
	// Read Only: true
	Version() int64
	SetVersion(int64)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type eventSource struct {
	alertBodyTemplateField string

	alertEffectiveIvalField *int32

	alertLevelField string

	alertSubjectTemplateField string

	appliesToField string

	clearAfterAckField bool

	collectorField string

	descriptionField string

	filtersField []*RestEventSourceFilter

	groupField string

	idField int32

	nameField *string

	suppressDuplicatesESField bool

	tagsField string

	technologyField string

	versionField int64
}

// AlertBodyTemplate gets the alert body template of this polymorphic type
func (m *eventSource) AlertBodyTemplate() string {
	return m.alertBodyTemplateField
}

// SetAlertBodyTemplate sets the alert body template of this polymorphic type
func (m *eventSource) SetAlertBodyTemplate(val string) {
	m.alertBodyTemplateField = val
}

// AlertEffectiveIval gets the alert effective ival of this polymorphic type
func (m *eventSource) AlertEffectiveIval() *int32 {
	return m.alertEffectiveIvalField
}

// SetAlertEffectiveIval sets the alert effective ival of this polymorphic type
func (m *eventSource) SetAlertEffectiveIval(val *int32) {
	m.alertEffectiveIvalField = val
}

// AlertLevel gets the alert level of this polymorphic type
func (m *eventSource) AlertLevel() string {
	return m.alertLevelField
}

// SetAlertLevel sets the alert level of this polymorphic type
func (m *eventSource) SetAlertLevel(val string) {
	m.alertLevelField = val
}

// AlertSubjectTemplate gets the alert subject template of this polymorphic type
func (m *eventSource) AlertSubjectTemplate() string {
	return m.alertSubjectTemplateField
}

// SetAlertSubjectTemplate sets the alert subject template of this polymorphic type
func (m *eventSource) SetAlertSubjectTemplate(val string) {
	m.alertSubjectTemplateField = val
}

// AppliesTo gets the applies to of this polymorphic type
func (m *eventSource) AppliesTo() string {
	return m.appliesToField
}

// SetAppliesTo sets the applies to of this polymorphic type
func (m *eventSource) SetAppliesTo(val string) {
	m.appliesToField = val
}

// ClearAfterAck gets the clear after ack of this polymorphic type
func (m *eventSource) ClearAfterAck() bool {
	return m.clearAfterAckField
}

// SetClearAfterAck sets the clear after ack of this polymorphic type
func (m *eventSource) SetClearAfterAck(val bool) {
	m.clearAfterAckField = val
}

// Collector gets the collector of this polymorphic type
func (m *eventSource) Collector() string {
	return "EventSource"
}

// SetCollector sets the collector of this polymorphic type
func (m *eventSource) SetCollector(val string) {
}

// Description gets the description of this polymorphic type
func (m *eventSource) Description() string {
	return m.descriptionField
}

// SetDescription sets the description of this polymorphic type
func (m *eventSource) SetDescription(val string) {
	m.descriptionField = val
}

// Filters gets the filters of this polymorphic type
func (m *eventSource) Filters() []*RestEventSourceFilter {
	return m.filtersField
}

// SetFilters sets the filters of this polymorphic type
func (m *eventSource) SetFilters(val []*RestEventSourceFilter) {
	m.filtersField = val
}

// Group gets the group of this polymorphic type
func (m *eventSource) Group() string {
	return m.groupField
}

// SetGroup sets the group of this polymorphic type
func (m *eventSource) SetGroup(val string) {
	m.groupField = val
}

// ID gets the id of this polymorphic type
func (m *eventSource) ID() int32 {
	return m.idField
}

// SetID sets the id of this polymorphic type
func (m *eventSource) SetID(val int32) {
	m.idField = val
}

// Name gets the name of this polymorphic type
func (m *eventSource) Name() *string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *eventSource) SetName(val *string) {
	m.nameField = val
}

// SuppressDuplicatesES gets the suppress duplicates e s of this polymorphic type
func (m *eventSource) SuppressDuplicatesES() bool {
	return m.suppressDuplicatesESField
}

// SetSuppressDuplicatesES sets the suppress duplicates e s of this polymorphic type
func (m *eventSource) SetSuppressDuplicatesES(val bool) {
	m.suppressDuplicatesESField = val
}

// Tags gets the tags of this polymorphic type
func (m *eventSource) Tags() string {
	return m.tagsField
}

// SetTags sets the tags of this polymorphic type
func (m *eventSource) SetTags(val string) {
	m.tagsField = val
}

// Technology gets the technology of this polymorphic type
func (m *eventSource) Technology() string {
	return m.technologyField
}

// SetTechnology sets the technology of this polymorphic type
func (m *eventSource) SetTechnology(val string) {
	m.technologyField = val
}

// Version gets the version of this polymorphic type
func (m *eventSource) Version() int64 {
	return m.versionField
}

// SetVersion sets the version of this polymorphic type
func (m *eventSource) SetVersion(val int64) {
	m.versionField = val
}

// UnmarshalEventSourceSlice unmarshals polymorphic slices of EventSource
func UnmarshalEventSourceSlice(reader io.Reader, consumer runtime.Consumer) ([]EventSource, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []EventSource
	for _, element := range elements {
		obj, err := unmarshalEventSource(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalEventSource unmarshals polymorphic EventSource
func UnmarshalEventSource(reader io.Reader, consumer runtime.Consumer) (EventSource, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalEventSource(data, consumer)
}

func unmarshalEventSource(data []byte, consumer runtime.Consumer) (EventSource, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the collector property.
	var getType struct {
		Collector string `json:"collector"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("collector", "body", getType.Collector); err != nil {
		return nil, err
	}

	// The value of collector is used to determine which type to create and unmarshal the data into
	switch getType.Collector {
	case "EventSource":
		var result eventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "RestIPMIEventSource":
		var result RestIPMIEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "awsrss":
		var result AwsRssEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "azurerss":
		var result AzureRssEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "echo":
		var result EchoEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "gcpatom":
		var result GcpAtomEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "logfile":
		var result LogFileEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "scriptevent":
		var result ScriptEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "snmptrap":
		var result SnmpTrapEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "syslog":
		var result SysLogEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "wineventlog":
		var result WindowsEventLogEventSource
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid collector value: %q", getType.Collector)
}

// Validate validates this event source
func (m *eventSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertEffectiveIval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *eventSource) validateAlertEffectiveIval(formats strfmt.Registry) error {

	if err := validate.Required("alertEffectiveIval", "body", m.AlertEffectiveIval()); err != nil {
		return err
	}

	return nil
}

func (m *eventSource) validateFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.Filters()) { // not required
		return nil
	}

	for i := 0; i < len(m.Filters()); i++ {
		if swag.IsZero(m.filtersField[i]) { // not required
			continue
		}

		if m.filtersField[i] != nil {
			if err := m.filtersField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("filters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *eventSource) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", int32(m.ID())); err != nil {
		return err
	}

	return nil
}

func (m *eventSource) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this event source based on the context it is used
func (m *eventSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *eventSource) contextValidateFilters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Filters()); i++ {

		if m.filtersField[i] != nil {
			if err := m.filtersField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("filters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *eventSource) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int32(m.ID())); err != nil {
		return err
	}

	return nil
}

func (m *eventSource) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "version", "body", int64(m.Version())); err != nil {
		return err
	}

	return nil
}
